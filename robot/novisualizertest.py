'''
Naruda: 2019-1 AJOU Univ. major of Software department Capstone project
Robot main firmware made by "Park Jun-Hyuk" (github nickname 'BrightBurningPark').

Robot can drive by itself, localize position and direction in given map.
it can also build the map from zero.

I Love my school and the Capstone Program SO MUCH. it's true story ^^.
'''
# python basic or pip-installed library import
import sys
import math
import time
import threading

# adding ./lib dir to use modules
import sys
sys.path.append('./lib')
# modules under lib directory
import ntdriver         # network driver
import pathengine       # shortest path finding engine
import rpslam           # BreezySLAM(tinySLAM Implementation) with RPLidar A1

# General variables like Path, Var, Name, etc...
PATH_ROBOT = "/home/odroid/capdi/robot" # robot SW top path
PATH_MAP = PATH_ROBOT + "/maps"          # map directory
PATH_LIB = PATH_ROBOT + "/lib"          # libraries
MAP_NAME_NO_SLAM = 'MAP_NO_SLAM.png'    # map name generated by no_map_slam
MAP_NAME_YES_SLAM = 'MAP_YES_SLAM.png'  # map name pre-drawn

# flag_slam_yn = None # this variable is under the __main__ code


def testcode():
    print('current position / ', narslam.x, narslam.y)
    dest_x = int(input('x>> '))
    dest_y = int(input('y>> '))

    while math.hypot(dest_x - narslam.x, dest_y - narslam.y) > 50:
        print('DISTANCE: ', math.hypot(dest_x - narslam.x, dest_y - narslam.y), '| while entered', )
        dx = dest_x - narslam.x
        dy = dest_y - narslam.y
        if abs(dx) <= 10:
            dx = 0
        if abs(dy) <= 10:
            dy = 0

        rad = math.atan2(dx, dy)
        deg = math.degrees(rad)
    
        if deg < 0:
            deg = 360 + deg

        print('degree: ', deg, ' | ', narslam.theta, ' | (', narslam.x, ', ', narslam.y, ')')

        if abs(deg - narslam.theta) <= 180:
            if narslam.theta - 7.5 > deg:
                nxt.send(ntdriver.LEFT)
            elif narslam.theta + 7.5 < deg:
                nxt.send(ntdriver.RIGHT)
            else:
                nxt.send(ntdriver.FORWARD)
        else:
            if narslam.theta - 7.5 > deg:
                nxt.send(ntdriver.RIGHT)
            elif narslam.theta + 7.5 < deg:
                nxt.send(ntdriver.LEFT)
            else:
                nxt.send(ntdriver.FORWARD)

        time.sleep(0.2)

    nxt.send(ntdriver.STOP)
    print('arrived to destination')

    print("done")
    print(narslam.x, narslam.y, narslam.theta)


def connect_all():
    # connecting functions comes here. there should be exception handling, but i have no time.
    nxt.connect()

if __name__ == "__main__":
    print ('firmware started')
    nxt         = ntdriver.lego_nxt()
    navi        = pathengine.navigation()
    narslam     = rpslam.narlam()
    print('instances generated successfully from the library modules')

    connect_all()
    print('all connection established')

    flag_slam_yn = input('select SLAM mode (y: do slam with pre-set map / n: do real SLAM) >> ')
    if flag_slam_yn == 'y':
        #TODO: do yes map slam
        path_map_name = PATH_MAP + '/' + MAP_NAME_YES_SLAM
        t_slam = threading.Thread(target=narslam.slam_yes_map, args=(path_map_name,))
    elif flag_slam_yn == 'n':
        #TODO: do no map slam
        path_map_name = PATH_MAP + '/' + MAP_NAME_NO_SLAM
        t_slam = threading.Thread(target=narslam.slam_no_map, args=(path_map_name,))
    else:
        print('error: invalid selection')
        sys.exit(-1)

    t_slam.start()

    while True:
        cmd = input('test >> ')
        if cmd == 'exit':
            narslam.flag = 1
            t_slam.join()
            print('exit')
            sys.exit(-1)
        nxt.send(cmd)
        print('(', narslam.x/1000, '|', narslam.y/1000, '|', narslam.theta, ')')

        
