'''
Naruda: 2019-1 AJOU Univ. major of Software department Capstone project
Robot main firmware made by "Park Jun-Hyuk" (github nickname 'BrightBurningPark').

Robot can drive by itself, localize position and direction in given map.
it can also build the map from zero.

I Love my school and the Capstone Program SO MUCH. it's true story ^^.
'''
# python basic or pip-installed library import
import sys
import math
import time
import threading

# adding ./lib dir to use modules
import sys
sys.path.append('./lib')
# modules under lib directory
import ntdriver         # network driver
import pathengine       # shortest path finding engine
import rpslam           # BreezySLAM(tinySLAM Implementation) with RPLidar A1

# General variables like Path, Var, Name, etc...
PATH_ROBOT = "/home/odroid/capdi/robot" # robot SW top path
PATH_MAP = PATH_ROBOT + "/maps"          # map directory
PATH_LIB = PATH_ROBOT + "/lib"          # libraries
MAP_NAME_NO_SLAM = 'MAP_NO_SLAM.png'    # map name generated by no_map_slam
MAP_NAME_YES_SLAM = 'MAP_YES_SLAM.png'  # map name pre-drawn

# flag_slam_yn = None # this variable is under the __main__ code


def auto_drive(dest):
    print('current position / ', narslam.x, narslam.y)
    dest_x = dest[0]#int(input('x>> '))
    dest_y = dest[1]#int(input('y>> '))

    while math.hypot(dest_x - narslam.x, dest_y - narslam.y) > 50:
        print('DISTANCE: ', math.hypot(dest_x - narslam.x, dest_y - narslam.y), '| while entered', )
        dx = dest_x - narslam.x
        dy = dest_y - narslam.y
        if abs(dx) <= 10:
            dx = 0
        if abs(dy) <= 10:
            dy = 0

        rad = math.atan2(dx, dy)
        deg = math.degrees(rad)
    
        if deg < 0:
            deg = 360 + deg
        #add 180 and %360 here
        #deg = (deg + 180) % 360

        print('degree: ', deg, ' | ', narslam.theta, ' | (', narslam.x, ', ', narslam.y, ')')

        if abs(deg - narslam.theta) <= 180:
            if narslam.theta - 7.5 > deg:
                nxt.send(ntdriver.LEFT)
            elif narslam.theta + 7.5 < deg:
                nxt.send(ntdriver.RIGHT)
            else:
                nxt.send(ntdriver.FORWARD)
        else:
            if narslam.theta - 7.5 > deg:
                nxt.send(ntdriver.RIGHT)
            elif narslam.theta + 7.5 < deg:
                nxt.send(ntdriver.LEFT)
            else:
                nxt.send(ntdriver.FORWARD)

        time.sleep(0.2)

    nxt.send(ntdriver.STOP)
    print('arrived to destination')
    print('(', narslam.x, narslam.y, narslam.theta, ')')


def testcode():
    print('input destination cordination in milimeter here')
    dest_x_milimeter = input('X in milimeter>> ')
    dest_y_miiimeter = input('Y in milimeter>> ')
    dest_milimeter = (dest_x_milimeter, dest_y_milimeter)
    
    start_milimeter = (narslam.x, narslam.y)
    
    navi.pathengine.navigation(PATH_MAP + '/' + MAP_NAME_YES_SLAM)
    navi.search(start_milimeter, dest_milimeter)
    navi.extract_rally()

    for point in navi.path_rally:
        auto_drive(point)
        print('drive_done')
    
    print(navi.path_rally)

    


if __name__ == "__main__":
    print ('firmware started')
    narslam     = rpslam.narlam()
    #TODO: do yes map slam
    path_map_name = PATH_MAP + '/' + MAP_NAME_YES_SLAM
    t_slam = threading.Thread(target=narslam.slam_yes_map, args=(path_map_name,))
    t_slam.start()
    print('SLAM activated')
    
    nxt = ntdriver.lego_nxt()
    nxt.connect()
    nxt.send('s60')
    print('nxt connected')


    while(1):
        cmd = input("please give me order\n(\"goto\": run testcode | 0,1,2,3,4: move)\n>> ")
        if cmd == 'goto':
            testcode()
            print('testcode done')
        elif cmd == 'exit':
            print('exit')
            narslam.flag = 1
            t_slam.join()
            sys.exit(0)
        else:
            nxt.send(cmd)
        
        print('(', narslam.x, '|', narslam.y, '|', narslam.theta, ')')

        
